{"name": "IofCompleteRequest", "markdown": "# IofCompleteRequest\n\n## 定义\n```c\nVOID IofCompleteRequest(\n  _In_ PIRP Irp,\n  _In_ CCHAR PriorityBoost\n);\n```\n\n## 描述\n`IofCompleteRequest` 是 Windows 内核提供的一个函数，用于完成一个 I/O 请求包（IRP）。这个函数通常在驱动程序处理完 IRP 后调用，以通知系统该请求已经完成。参数 `Irp` 指向要完成的 IRP 结构体，而 `PriorityBoost` 参数指示是否应该提升发出此 IRP 的线程的优先级，这有助于提高响应性。当设置为 `IO_NO_INCREMENT` 时，不提升线程优先级；若设为其他值，则会根据情况适当提升。此 API 广泛应用于各种设备驱动开发中，尤其是在需要直接管理硬件资源或处理复杂 I/O 操作的情况下。\n\n> IAT Address: 0x12058", "addresses": ["0x12058", "0x140003110", "IofCompleteRequest", "0x7FFA6E0C3D80"]}
{"name": "MmFreeContiguousMemorySpecifyCache", "markdown": "# MmFreeContiguousMemorySpecifyCache\n\n## 定义\n\n```c\nVOID MmFreeContiguousMemorySpecifyCache(\n  PVOID BaseAddress,\n  SIZE_T Size,\n  MEMORY_CACHING_TYPE CacheType\n);\n```\n\n## 描述\n\n`MmFreeContiguousMemorySpecifyCache` 用于释放之前通过 `MmAllocateContiguousMemorySpecifyCache` 分配的连续物理内存块。该函数的关键参数包括 `BaseAddress`（分配内存的基地址）、`Size`（分配的内存大小）以及 `CacheType`（指定的缓存类型）。典型使用场景是在驱动程序中需要动态管理大块连续内存时，例如 DMA 操作或硬件设备交互。\n\n> IAT Address: 0x12010", "addresses": ["0x12010", "0x7FFA6E0C3C00"]}
{"name": "KeInsertQueueDpc", "markdown": "# KeInsertQueueDpc\n\n## 定义\n\n```c\nBOOLEAN KeInsertQueueDpc(\n  PRKDPC Dpc,\n  PVOID  SystemArgument1,\n  PVOID  SystemArgument2\n);\n```\n\n## 描述\n\n`KeInsertQueueDpc` 是 Windows 内核中用于将一个延迟过程调用（DPC）对象插入到系统 DPC 队列的函数。DPC 是一种机制，允许驱动程序在低于调度优先级的中断级别执行延迟任务，通常用于处理硬件中断的后续工作。关键参数包括 `Dpc`（指向 DPC 对象的指针）、`SystemArgument1` 和 `SystemArgument2`（传递给 DPC 回调函数的上下文参数）。典型使用场景包括设备驱动程序在中断服务例程（ISR）完成后调度后续任务，例如完成 I/O 操作或释放资源。\n\n> IAT Address: 0x12050", "addresses": ["0x12050", "0x7FFA6E0C3D00"]}
{"name": "RtlGetVersion", "markdown": "# RtlGetVersion\n\n## 定义\n\n```c\nNTSTATUS RtlGetVersion(\n  PRTL_OSVERSIONINFOW lpVersionInformation\n);\n```\n\n## 描述\n\n`RtlGetVersion` 是一个 Windows 内核 API，用于获取操作系统的版本信息。它填充传入的 `RTL_OSVERSIONINFOW` 结构体，包含主版本号、次版本号、构建号等详细信息。该函数通常在驱动程序或系统级组件中使用，以确保兼容性或根据操作系统版本调整行为。与用户模式下的 `GetVersionEx` 不同，`RtlGetVersion` 提供更可靠的结果，不会受到应用程序清单的影响。\n\n> IAT Address: 0x140003108", "addresses": ["0x140003108", "RtlGetVersion"]}
{"name": "ObReferenceObjectByHandle", "markdown": "# ObReferenceObjectByHandle\n\n## 定义\n\n```c\nNTSTATUS ObReferenceObjectByHandle(\n  HANDLE                     Handle,\n  ACCESS_MASK                DesiredAccess,\n  POBJECT_TYPE               ObjectType,\n  KPROCESSOR_MODE            AccessMode,\n  PVOID                      *Object,\n  POBJECT_HANDLE_INFORMATION HandleInformation\n);\n```\n\n## 描述\n\n`ObReferenceObjectByHandle` 是 Windows 内核中的一个 API，用于通过句柄获取内核对象的指针，并增加该对象的引用计数。它的主要作用是将用户模式或内核模式下的句柄转换为实际的内核对象指针，以便驱动程序可以直接操作底层对象。关键参数包括 `Handle`（要解析的句柄）、`DesiredAccess`（请求的访问权限）、`ObjectType`（目标对象的类型，如文件、进程等）以及 `AccessMode`（指定句柄的访问模式）。典型使用场景包括文件系统过滤驱动、设备驱动程序和需要直接操作内核对象的安全工具。\n\n> IAT Address: 0x140003118", "addresses": ["0x140003118", "ObReferenceObjectByHandle"]}
{"name": "ObfDereferenceObject", "markdown": "# ObfDereferenceObject\n\n## 定义\n\n```c\nVOID ObfDereferenceObject(\n  PVOID Object\n);\n```\n\n## 描述\n\n`ObfDereferenceObject` 是 Windows 内核中的一个函数，用于减少对象的引用计数。当一个内核对象的引用计数降为零时，系统会释放该对象占用的资源。此函数通常在驱动程序或内核组件中使用，以确保正确管理对象的生命周期。典型场景包括在完成对某个对象的操作后释放引用，或者在清理代码路径中解除对对象的引用。\n\n> IAT Address: 0x140003120", "addresses": ["0x140003120", "ObfDereferenceObject"]}
{"name": "PsLookupProcessByProcessId", "markdown": "# PsLookupProcessByProcessId\n\n## 定义\n\n```c\nNTSTATUS PsLookupProcessByProcessId(\n  HANDLE    ProcessId,\n  PEPROCESS *Process\n);\n```\n\n## 描述\n\n`PsLookupProcessByProcessId` 是一个 Windows 内核 API，用于根据进程 ID 查找并引用对应的内核 `EPROCESS` 结构。其关键参数包括 `ProcessId`（目标进程的唯一标识符）和 `Process`（输出参数，用于返回指向 `EPROCESS` 的指针）。该函数通常在需要操作或查询特定进程的内核上下文中使用，例如实现驱动程序中的进程监控或调试功能。调用成功后，返回的 `EPROCESS` 对象引用计数会增加，因此调用者必须通过 `ObDereferenceObject` 释放引用以避免资源泄漏。\n\n> IAT Address: 0x140003128", "addresses": ["0x140003128", "PsLookupProcessByProcessId"]}
{"name": "ObOpenObjectByPointer", "markdown": "# ObOpenObjectByPointer\n\n## 定义\n\n```c\nNTSTATUS ObOpenObjectByPointer(\n  PVOID                 Object,\n  ULONG                 HandleAttributes,\n  PACCESS_STATE         PassedAccessState,\n  ACCESS_MASK           DesiredAccess,\n  POBJECT_TYPE          ObjectType,\n  KPROCESSOR_MODE       AccessMode,\n  PHANDLE               Handle\n);\n```\n\n## 描述\n\n`ObOpenObjectByPointer` 是 Windows 内核中的一个函数，用于根据对象指针创建一个句柄。它通常在需要将内核对象暴露给用户模式或需要通过句柄访问对象时使用。关键参数包括 `Object`（指向目标对象的指针）、`DesiredAccess`（请求的访问权限）、`ObjectType`（对象类型，如文件、进程等）以及 `Handle`（返回的句柄）。典型场景包括驱动程序中操作文件对象、设备对象或进程对象时需要生成句柄以便进一步操作。\n\n> IAT Address: 0x140003130", "addresses": ["0x140003130", "ObOpenObjectByPointer"]}
{"name": "memmove", "markdown": "# memmove\n\n## 定义\n```c\nvoid *memmove(void *dest, const void *src, size_t n);\n```\n\n## 描述\n`memmove` 函数用于将 `src` 指向的内存区域的前 `n` 个字节复制到 `dest` 所指向的内存区域。该函数与 `memcpy` 类似，但 `memmove` 可以处理源和目标区域重叠的情况，而不会导致数据损坏。这是通过在内部使用不同的算法来保证即使在源和目标区域有重叠的情况下也能正确地复制数据。`memmove` 的关键参数包括目的地址 `dest`、源地址 `src` 以及要复制的字节数 `n`。此函数通常用于需要确保安全复制内存块的场景中，尤其是在不清楚或无法控制源和目标缓冲区位置关系时。\n\n> IAT Address: 0x11790", "addresses": ["0x11790", "0x7FFA6E0C3B80"]}
{"name": "DeferredRoutine", "markdown": "# DeferredRoutine\n\n## 定义\n```c\nVOID NTAPI DeferredRoutine(\n  _In_ PDEVICE_OBJECT DeviceObject,\n  _In_ PVOID Context\n);\n```\n\n## 描述\n`DeferredRoutine` 是一个内核模式驱动程序中使用的回调函数原型，它通常作为 `IoInitializeDpcRequest` 函数的一个参数被指定。这个函数在 DPC（延迟过程调用）上下文中被执行，用于处理那些需要在中断服务例程之后但又不能直接在 ISR 中执行的任务。`DeviceObject` 参数指向触发此 DPC 的设备对象，而 `Context` 参数则允许开发者传递任何类型的上下文信息给该回调函数，这使得 `DeferredRoutine` 可以访问到完成其任务所需的数据或状态。\n\n这种机制常见于需要快速响应硬件事件同时又必须保证不会阻塞系统关键路径的场景下，比如网络驱动程序中的数据包接收处理或是磁盘 I/O 请求的完成通知等场合。通过将耗时的操作推迟到 DPC 级别来执行，可以确保系统的响应性和稳定性。\n\n> IAT Address: 0x7FFA6E0C3C80", "addresses": ["0x7FFA6E0C3C80"]}
